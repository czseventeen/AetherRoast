#!/usr/bin/env python3
import time
import threading
import RPi.GPIO as GPIO
from simple_pid import PID
import csv
import os
import sys

class TemperatureController:
    def __init__(
        self,
        ssr_pin=26,
        temp_raw_path="/sys/bus/iio/devices/iio:device0/in_temp_raw",
        temp_scale_path="/sys/bus/iio/devices/iio:device0/in_temp_scale",
        initial_setpoint=60.0,
        pwm_period=0.5,
        pid_gains=(2.3, 0.25, 2.5),
        roast_profile_file=None,  # CSV file path
        log_file="roast_log.csv"
    ):
        self.ssr_pin = ssr_pin
        self.temp_raw_path = temp_raw_path
        self.temp_scale_path = temp_scale_path
        self.pwm_period = pwm_period
        self.setpoint = initial_setpoint
        self.running = False
        self.roast_profile = []
        self.log_file = log_file

        # PID setup
        Kp, Ki, Kd = pid_gains
        self.pid = PID(Kp, Ki, Kd, setpoint=self.setpoint)
        self.pid.output_limits = (0, self.pwm_period)

        # GPIO setup
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self.ssr_pin, GPIO.OUT)
        GPIO.output(self.ssr_pin, GPIO.LOW)

        # Load roast profile if file provided
        if roast_profile_file:
            self.load_roast_profile(roast_profile_file)

        # Internal
        self.start_time = None

        # Initialize logging
        self.init_log()

    # --------------------
    # Roast Profile
    # --------------------
    def load_roast_profile(self, file_path):
        if not os.path.exists(file_path):
            print(f"[ERROR] Roast profile file not found: {file_path}")
            sys.exit(1)
        self.roast_profile = []
        with open(file_path, newline='') as csvfile:
            reader = csv.reader(csvfile)
            for row in reader:
                try:
                    t_sec = float(row[0])
                    temp = float(row[1])
                    self.roast_profile.append((t_sec, temp))
                except ValueError:
                    print(f"[WARN] Skipping invalid line: {row}")
        self.roast_profile.sort(key=lambda x: x[0])
        print(f"[INFO] Loaded roast profile: {len(self.roast_profile)} points")

    def interpolate_setpoint(self, elapsed):
        """Return the target temperature at the current elapsed time based on roast_profile."""
        if not self.roast_profile or elapsed <= self.roast_profile[0][0]:
            return self.roast_profile[0][1] if self.roast_profile else self.setpoint
        for i in range(1, len(self.roast_profile)):
            t0, temp0 = self.roast_profile[i - 1]
            t1, temp1 = self.roast_profile[i]
            if elapsed <= t1:
                ratio = (elapsed - t0) / (t1 - t0)
                return temp0 + ratio * (temp1 - temp0)
        return self.roast_profile[-1][1]

    # --------------------
    # Temperature reading
    # --------------------
    def read_temperature(self):
        with open(self.temp_raw_path) as f:
            raw = int(f.read().strip())
        with open(self.temp_scale_path) as f:
            scale = int(f.read().strip())
        return raw * scale / 1000.0

    # --------------------
    # Logging
    # --------------------
    def init_log(self):
        self.log_fh = open(self.log_file, "w", newline="")
        self.csv_writer = csv.writer(self.log_fh)
        self.csv_writer.writerow(["timestamp_sec", "elapsed_sec", "target_temp_C", "actual_temp_C", "pid_on_time_s"])

    def log_step(self, elapsed, target_temp, actual_temp, on_time):
        self.csv_writer.writerow([time.time(), elapsed, target_temp, actual_temp, on_time])
        self.log_fh.flush()

    # --------------------
    # Control
    # --------------------
    def set_target(self, target_temp):
        self.setpoint = target_temp
        self.pid.setpoint = target_temp
        print(f"[INFO] Target temperature updated to {target_temp:.1f} °C")

    def control_step(self):
        # Update setpoint from roast profile
        if self.roast_profile and self.start_time is not None:
            elapsed = time.time() - self.start_time
            self.setpoint = self.interpolate_setpoint(elapsed)
            self.pid.setpoint = self.setpoint
        else:
            elapsed = time.time() - self.start_time if self.start_time else 0

        temp = self.read_temperature()
        on_time = self.pid(temp)
        print(f"Temp: {temp:.2f} °C | Target: {self.setpoint:.2f} °C | ON: {on_time:.2f}s")

        # Log data
        self.log_step(elapsed, self.setpoint, temp, on_time)

        # SSR time-proportioning control
        if on_time > 0:
            GPIO.output(self.ssr_pin, GPIO.HIGH)
            time.sleep(on_time)
        if on_time < self.pwm_period:
            GPIO.output(self.ssr_pin, GPIO.LOW)
            time.sleep(self.pwm_period - on_time)

    def start(self):
        self.running = True
        self.start_time = time.time()
        print(f"[INFO] Starting temperature control at {self.setpoint:.1f} °C")
        try:
            while self.running:
                self.control_step()
        except Exception as e:
            print(f"[ERROR] {e}")
        finally:
            self.shutdown()

    def shutdown(self):
        if not self.running:
            return
        print("[INFO] Shutting down controller...")
        self.running = False
        GPIO.output(self.ssr_pin, GPIO.LOW)
        GPIO.cleanup()
        self.log_fh.close()
        print(f"[INFO] System shut down safely. SSR OFF. Log saved to {self.log_file}")

    def input_loop(self):
        while self.running:
            try:
                inp = input("Enter new target temperature (°C) or Ctrl+C to exit: ").strip()
                if inp:
                    try:
                        new_target = float(inp)
                        self.set_target(new_target)
                    except ValueError:
                        print("[WARN] Invalid number, try again.")
            except (EOFError, KeyboardInterrupt):
                print("\n[INFO] KeyboardInterrupt detected — stopping control.")
                self.shutdown()
                break


# ====== MAIN ======
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python3 profile_roasting.py <roast_profile.csv>")
        sys.exit(1)

    roast_profile_file = sys.argv[1]

    controller = TemperatureController(
        pid_gains=(2.3, 0.25, 2.5),
        pwm_period=0.5,
        roast_profile_file=roast_profile_file,
        log_file="roast_log.csv",
    )

    try:
        controller.running = True
        control_thread = threading.Thread(target=controller.start)
        control_thread.start()

        controller.input_loop()

    except KeyboardInterrupt:
        print("\n[INFO] Stopping by user request...")

    finally:
        controller.shutdown()

